###############################################################################
#                                                                             #
#                                                       10/Feb/2015  19:50:54 #
# IAR ANSI C/C++ Compiler V6.30.4.23288/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\src\Sources #
#                    \C\Component_C\adc.c                                     #
#    Command line =  E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\src\Sources #
#                    \C\Component_C\adc.c -D IAR -D TWR_K60N512 -lCN          #
#                    E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\bin\Flash\L #
#                    ist\ -lB E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\bi #
#                    n\Flash\List\ -o E:\单片机\K60\K60核心板源代码\03_LQ_uar #
#                    t_int\bin\Flash\Obj\ --no_cse --no_unroll --no_inline    #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\MyProgramFiles\IAR       #
#                    V6.3\arm\INC\c\DLib_Config_Normal.h" -I                  #
#                    E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\src\Sources #
#                    \H\ -I E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\src\ #
#                    Sources\H\Component_H\ -I E:\单片机\K60\K60核心板源代码\ #
#                    03_LQ_uart_int\src\Sources\H\Frame_H\ -Ol                #
#                    --use_c++_inline                                         #
#    List file    =  E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\bin\Flash\L #
#                    ist\adc.lst                                              #
#    Object file  =  E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\bin\Flash\O #
#                    bj\adc.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

E:\单片机\K60\K60核心板源代码\03_LQ_uart_int\src\Sources\C\Component_C\adc.c
      1          #include "adc.h"
      2          
      3          

   \                                 In section .bss, align 4
      4          tADC_Config   Master_Adc_Config;
   \                     Master_Adc_Config:
   \   00000000                      DS8 16
      5          //============================================================================
      6          //函数名称：hw_adc_init
      7          //函数返回：0 成功 ，1 失败
      8          //参数说明：MoudelNumber：模块号
      9          //功能概要：AD初始化
     10          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     11          uint8 hw_adc_init(int MoudelNumber)
     12          {
     13              if(MoudelNumber == 0)//模块0
   \                     hw_adc_init:
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD110             BNE.N    ??hw_adc_init_0
     14              {
     15                  SIM_SCGC6 |= (SIM_SCGC6_ADC0_MASK );
   \   00000004   0x....             LDR.N    R0,??DataTable3  ;; 0x4004803c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000000C   0x....             LDR.N    R1,??DataTable3  ;; 0x4004803c
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     16          
     17                  SIM_SOPT7 &= ~(SIM_SOPT7_ADC0ALTTRGEN_MASK  |
     18                                SIM_SOPT7_ADC0PRETRGSEL_MASK);
   \   00000010   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40048018
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF030 0x0090      BICS     R0,R0,#0x90
   \   00000018   0x....             LDR.N    R1,??DataTable3_1  ;; 0x40048018
   \   0000001A   0x6008             STR      R0,[R1, #+0]
     19                  SIM_SOPT7 = SIM_SOPT7_ADC0TRGSEL(0);
   \   0000001C   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40048018
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6001             STR      R1,[R0, #+0]
     20              }
     21              else if(MoudelNumber == 1)//模块1
     22              {      
     23                  SIM_SCGC3 |= (SIM_SCGC3_ADC1_MASK );
     24          
     25                  SIM_SOPT7 &= ~(SIM_SOPT7_ADC1ALTTRGEN_MASK  |
     26                                SIM_SOPT7_ADC1PRETRGSEL_MASK) ;
     27                  SIM_SOPT7 = SIM_SOPT7_ADC1TRGSEL(0);
     28              }
     29              else
     30              {
     31                  return 0;
     32              }
     33              
     34              return 1;
   \                     ??hw_adc_init_1:
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??hw_adc_init_2:
   \   00000024   0x4770             BX       LR               ;; return
   \                     ??hw_adc_init_0:
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD10F             BNE.N    ??hw_adc_init_3
   \   0000002A   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40048030
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000032   0x....             LDR.N    R1,??DataTable3_2  ;; 0x40048030
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40048018
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x4010      BICS     R0,R0,#0x9000
   \   0000003E   0x....             LDR.N    R1,??DataTable3_1  ;; 0x40048018
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40048018
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6001             STR      R1,[R0, #+0]
   \   00000048   0xE7EB             B.N      ??hw_adc_init_1
   \                     ??hw_adc_init_3:
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE7EA             B.N      ??hw_adc_init_2
     35          }
     36          
     37          
     38          
     39          //============================================================================
     40          //函数名称：hw_ad_once
     41          //函数返回：无符号结果值(范围:0-4095) 
     42          //参数说明：MoudelNumber：模块号
     43          //               Channel：通道号
     44          //              accuracy：精度
     45          //功能概要：采集一次一路模拟量的AD值    
     46          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     47          uint16 hw_ad_once(int MoudelNumber,int Channel,uint8 accuracy)//采集某路模拟量的AD值
     48          {
   \                     hw_ad_once:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
     49              uint16 result = 0;
   \   00000004   0x2400             MOVS     R4,#+0
     50              //开始ADC转换
     51              hw_adc_convertstart(MoudelNumber, Channel, accuracy);	
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       hw_adc_convertstart
     52          
     53              if(MoudelNumber == 0)
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD10C             BNE.N    ??hw_ad_once_0
     54              {
     55                  while (( ADC0_SC1A & ADC_SC1_COCO_MASK ) != ADC_SC1_COCO_MASK)
   \                     ??hw_ad_once_1:
   \   00000012   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0600             LSLS     R0,R0,#+24
   \   00000018   0xD5FB             BPL.N    ??hw_ad_once_1
     56                  {
     57          
     58                  }
     59                  result = ADC0_RA;        
   \   0000001A   0x....             LDR.N    R0,??DataTable3_4  ;; 0x4003b010
   \   0000001C   0x6804             LDR      R4,[R0, #+0]
     60                  ADC0_SC1A &= ~ADC_SC1_COCO_MASK;
   \   0000001E   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000026   0x....             LDR.N    R1,??DataTable3_3  ;; 0x4003b000
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0xE00B             B.N      ??hw_ad_once_2
     61              }
     62              else
     63              {
     64                  while (( ADC1_SC1A & ADC_SC1_COCO_MASK ) != ADC_SC1_COCO_MASK)
   \                     ??hw_ad_once_0:
   \   0000002C   0x....             LDR.N    R0,??DataTable3_5  ;; 0x400bb000
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0600             LSLS     R0,R0,#+24
   \   00000032   0xD5FB             BPL.N    ??hw_ad_once_0
     65                  {
     66          
     67                  }
     68                  result = ADC1_RA;        
   \   00000034   0x....             LDR.N    R0,??DataTable3_6  ;; 0x400bb010
   \   00000036   0x6804             LDR      R4,[R0, #+0]
     69                  ADC1_SC1A &= ~ADC_SC1_COCO_MASK;
   \   00000038   0x....             LDR.N    R0,??DataTable3_5  ;; 0x400bb000
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000040   0x....             LDR.N    R1,??DataTable3_5  ;; 0x400bb000
   \   00000042   0x6008             STR      R0,[R1, #+0]
     70              }
     71          
     72              return result;
   \                     ??hw_ad_once_2:
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     73          }
     74          
     75          //============================================================================
     76          //函数名称：hw_ad_mid
     77          //函数返回：无符号结果值(范围:0-4095) 
     78          //参数说明：MoudelNumber：模块号
     79          //               Channel：通道号
     80          //              accuracy：精度
     81          //功能概要：中值滤波后的结果(范围:0-4095) 
     82          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     83          uint16 hw_ad_mid(int MoudelNumber,int Channel,uint8 accuracy) //中值滤波
     84          {
   \                     hw_ad_mid:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
     85          	uint16 i,j,k,tmp;
     86          	//1.取3次A/D转换结果
     87          	i = hw_ad_once(MoudelNumber,Channel,accuracy);
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       hw_ad_once
   \   00000016   0x0007             MOVS     R7,R0
     88          	j = hw_ad_once(MoudelNumber,Channel,accuracy);
   \   00000018   0x0032             MOVS     R2,R6
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       hw_ad_once
   \   00000024   0x4680             MOV      R8,R0
     89          	k = hw_ad_once(MoudelNumber,Channel,accuracy);
   \   00000026   0x0032             MOVS     R2,R6
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       hw_ad_once
   \   00000032   0x0001             MOVS     R1,R0
     90          	//2.取中值
     91          	if (i > j)
   \   00000034   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000038   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003A   0x45B8             CMP      R8,R7
   \   0000003C   0xD202             BCS.N    ??hw_ad_mid_0
     92          	{
     93          		tmp = i; i = j; j = tmp;
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x4647             MOV      R7,R8
   \   00000042   0x4680             MOV      R8,R0
     94          	}
     95          	if (k > j) 
   \                     ??hw_ad_mid_0:
   \   00000044   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000048   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004A   0x4588             CMP      R8,R1
   \   0000004C   0xD201             BCS.N    ??hw_ad_mid_1
     96          	  tmp = j;
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0xE006             B.N      ??hw_ad_mid_2
     97          	else if(k > i) 
   \                     ??hw_ad_mid_1:
   \   00000052   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000054   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000056   0x428F             CMP      R7,R1
   \   00000058   0xD201             BCS.N    ??hw_ad_mid_3
     98          	  tmp = k; 
   \   0000005A   0x0008             MOVS     R0,R1
   \   0000005C   0xE000             B.N      ??hw_ad_mid_2
     99              else 
    100                tmp = i;
   \                     ??hw_ad_mid_3:
   \   0000005E   0x0038             MOVS     R0,R7
    101          	return tmp;
   \                     ??hw_ad_mid_2:
   \   00000060   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    102          }
    103          
    104          //============================================================================
    105          //函数名称：hw_ad_ave
    106          //函数返回：无符号结果值(范围:0-4095) 
    107          //参数说明：MoudelNumber：模块号
    108          //               Channel：通道号
    109          //              accuracy：精度
    110          //                     N:均值滤波次数(范围:0~255)
    111          //功能概要：均值滤波后的角度结果(范围:0-4095) 
    112          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    113          uint16 hw_ad_ave(int MoudelNumber,int Channel,uint8 accuracy,uint8 N) //均值滤波
    114          {
   \                     hw_ad_ave:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    115          	uint32 tmp = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    116          	uint8  i;
    117              for(i = 0; i < N; i++)
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xE009             B.N      ??hw_ad_ave_0
    118          		tmp += hw_ad_mid(MoudelNumber,Channel,accuracy);
   \                     ??hw_ad_ave_1:
   \   00000016   0x0032             MOVS     R2,R6
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       hw_ad_mid
   \   00000022   0xFA18 0xF880      UXTAH    R8,R8,R0
   \   00000026   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??hw_ad_ave_0:
   \   0000002A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000030   0x45B9             CMP      R9,R7
   \   00000032   0xD3F0             BCC.N    ??hw_ad_ave_1
    119          	tmp = tmp / N; 
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0xFBB8 0xF8F7      UDIV     R8,R8,R7
    120              return (uint16)tmp;
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    121          }
    122          //============================================================================
    123          //函数名称:hw_angle_convert()
    124          //函数返回:无符号结果值
    125          //参数说明:
    126          //功能概要:角度转换
    127          //============================================================================
    128          /*void Angle_convert()
    129          {
    130            float Rz, Angle;                            //要声明为全局变量
    131            Rz=180/(Z_MAX-Z_MIN);                       //用实验测出Z_MAX,Z_MIN
    132            g_fGravityAngle=Rz*(hw_ad_ave(int MoudelNumber,int Channel,uint8 accuracy,uint8 N)-C_ANGLE);
    133            return  g_fGravityAngle;
    134          }*/
    135          
    136          
    137          //============================================================================
    138          //函数名称：hw_Angleconvert()
    139          //函数返回：无符号结果值(范围:0-4095) 
    140          //参数说明：
    141          //功能概要：角度转换(范围:0-4095) 
    142          //============================================================================
    143          /*void hw_AngleSpeedconvert(void)
    144          {
    145            float AngleSpeed;
    146            //Rgyro=Rad/(Rg*K)
    147            AngleSpeed=R_GYRO*(hw_ad_ave(int MoudelNumber,int Channel,uint8 accuracy,uint8 N)-GYROSCOPE_OFFSET);
    148            return AngleSpeed;
    149          }*/
    150          //============================================================================
    151          //函数名称：hw_adc_convertstart
    152          //函数返回：0 成功 ，1 失败
    153          //参数说明：MoudelNumber：模块号
    154          //               Channel：通道号
    155          //              accuracy：精度
    156          //功能概要：开始adc转换
    157          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    158          uint8 hw_adc_convertstart(int MoudelNumber,int Channel,uint8 accuracy)
    159          {
   \                     hw_adc_convertstart:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    160              uint8 ADCCfg1Mode = 0;
   \   00000004   0x2100             MOVS     R1,#+0
    161              
    162              switch(accuracy)
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A08             CMP      R2,#+8
   \   0000000A   0xD006             BEQ.N    ??hw_adc_convertstart_0
   \   0000000C   0x2A0A             CMP      R2,#+10
   \   0000000E   0xD008             BEQ.N    ??hw_adc_convertstart_1
   \   00000010   0x2A0C             CMP      R2,#+12
   \   00000012   0xD004             BEQ.N    ??hw_adc_convertstart_2
   \   00000014   0x2A10             CMP      R2,#+16
   \   00000016   0xD006             BEQ.N    ??hw_adc_convertstart_3
   \   00000018   0xE007             B.N      ??hw_adc_convertstart_4
    163              {
    164                case 8:
    165                  ADCCfg1Mode = 0x00;
   \                     ??hw_adc_convertstart_0:
   \   0000001A   0x2100             MOVS     R1,#+0
    166                  break;
   \   0000001C   0xE006             B.N      ??hw_adc_convertstart_5
    167                case 12:
    168                  ADCCfg1Mode = 0x01;
   \                     ??hw_adc_convertstart_2:
   \   0000001E   0x2101             MOVS     R1,#+1
    169                  break;
   \   00000020   0xE004             B.N      ??hw_adc_convertstart_5
    170                case 10:
    171                  ADCCfg1Mode = 0x02;
   \                     ??hw_adc_convertstart_1:
   \   00000022   0x2102             MOVS     R1,#+2
    172                  break;
   \   00000024   0xE002             B.N      ??hw_adc_convertstart_5
    173                case 16:
    174                  ADCCfg1Mode = 0x03;
   \                     ??hw_adc_convertstart_3:
   \   00000026   0x2103             MOVS     R1,#+3
    175                  break;
   \   00000028   0xE000             B.N      ??hw_adc_convertstart_5
    176                default:
    177                  ADCCfg1Mode = 0x00;
   \                     ??hw_adc_convertstart_4:
   \   0000002A   0x2100             MOVS     R1,#+0
    178              }
    179              
    180            
    181              //初始化ADC默认配置
    182              Master_Adc_Config.CONFIG1  = ADLPC_NORMAL
    183                                        | ADC_CFG1_ADIV(ADIV_4)
    184                                        | ADLSMP_LONG
    185                                        | ADC_CFG1_MODE(ADCCfg1Mode)
    186                                        | ADC_CFG1_ADICLK(ADICLK_BUS);
   \                     ??hw_adc_convertstart_5:
   \   0000002C   0x0089             LSLS     R1,R1,#+2
   \   0000002E   0xF011 0x010C      ANDS     R1,R1,#0xC
   \   00000032   0xF051 0x0150      ORRS     R1,R1,#0x50
   \   00000036   0x....             LDR.N    R2,??DataTable3_7
   \   00000038   0x7011             STRB     R1,[R2, #+0]
    187              Master_Adc_Config.CONFIG2  = MUXSEL_ADCA
    188                                        | ADACKEN_DISABLED
    189                                        | ADHSC_HISPEED
    190                                        | ADC_CFG2_ADLSTS(ADLSTS_20) ;
   \   0000003A   0x....             LDR.N    R1,??DataTable3_7
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0x704A             STRB     R2,[R1, #+1]
    191              Master_Adc_Config.COMPARE1 = 0x1234u ;                 //任意值
   \   00000040   0x....             LDR.N    R1,??DataTable3_7
   \   00000042   0xF241 0x2234      MOVW     R2,#+4660
   \   00000046   0x804A             STRH     R2,[R1, #+2]
    192              Master_Adc_Config.COMPARE2 = 0x5678u ;                 //任意值
   \   00000048   0x....             LDR.N    R1,??DataTable3_7
   \   0000004A   0xF245 0x6278      MOVW     R2,#+22136
   \   0000004E   0x808A             STRH     R2,[R1, #+4]
    193                                                                    
    194              
    195              if(MoudelNumber == 0)
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD12A             BNE.N    ??hw_adc_convertstart_6
    196              {
    197                  if(Channel<=3)
   \   00000054   0x2C04             CMP      R4,#+4
   \   00000056   0xDA0B             BGE.N    ??hw_adc_convertstart_7
    198                  {
    199                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Channel);
   \   00000058   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   0000005C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000060   0x....             LDR.N    R1,??DataTable3_7
   \   00000062   0x7208             STRB     R0,[R1, #+8]
    200                      hw_adc_config_alt(ADC0_BASE_PTR, &Master_Adc_Config);  // 配置 ADC0
   \   00000064   0x....             LDR.N    R1,??DataTable3_7
   \   00000066   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   00000068   0x.... 0x....      BL       hw_adc_config_alt
    201                  }
    202                  
    203                  else if(Channel>3&&Channel<24)                             //4~23 使用 ADC0
    204                  {
    205                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Channel);
    206                      hw_adc_config_alt(ADC0_BASE_PTR, &Master_Adc_Config);  // 配置 ADC0
    207                  }
    208                  else if(Channel == 26)
    209                  {
    210                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Channel);
    211                      hw_adc_config_alt(ADC0_BASE_PTR, &Master_Adc_Config);  // 配置ADC0
    212                  }
    213                  else
    214                  {
    215                      return 0;
    216                  }
    217              }
    218              else
    219              {
    220                  if(Channel<=3)
    221                  {
    222                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Channel);
    223                      hw_adc_config_alt(ADC0_BASE_PTR, &Master_Adc_Config);  // 配置 ADC0
    224                  }
    225                  
    226                  if(Channel>3&&Channel<24)                             //4~23 使用 ADC1
    227                  {
    228                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Channel);
    229                      hw_adc_config_alt(ADC1_BASE_PTR, &Master_Adc_Config);  // 配置ADC1
    230                  }
    231                  else if(Channel == 26)
    232                  {
    233                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Channel);
    234                      hw_adc_config_alt(ADC1_BASE_PTR, &Master_Adc_Config);  // 配置ADC1
    235                  }
    236                  else
    237                  {
    238                      return 0;
    239                  }
    240              }
    241              return 1;
   \                     ??hw_adc_convertstart_8:
   \   0000006C   0x2001             MOVS     R0,#+1
   \                     ??hw_adc_convertstart_9:
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??hw_adc_convertstart_7:
   \   00000070   0x1F20             SUBS     R0,R4,#+4
   \   00000072   0x2814             CMP      R0,#+20
   \   00000074   0xD20A             BCS.N    ??hw_adc_convertstart_10
   \   00000076   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   0000007A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000007E   0x....             LDR.N    R1,??DataTable3_7
   \   00000080   0x7208             STRB     R0,[R1, #+8]
   \   00000082   0x....             LDR.N    R1,??DataTable3_7
   \   00000084   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   00000086   0x.... 0x....      BL       hw_adc_config_alt
   \   0000008A   0xE7EF             B.N      ??hw_adc_convertstart_8
   \                     ??hw_adc_convertstart_10:
   \   0000008C   0x2C1A             CMP      R4,#+26
   \   0000008E   0xD10A             BNE.N    ??hw_adc_convertstart_11
   \   00000090   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   00000094   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000098   0x....             LDR.N    R1,??DataTable3_7
   \   0000009A   0x7208             STRB     R0,[R1, #+8]
   \   0000009C   0x....             LDR.N    R1,??DataTable3_7
   \   0000009E   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   000000A0   0x.... 0x....      BL       hw_adc_config_alt
   \   000000A4   0xE7E2             B.N      ??hw_adc_convertstart_8
   \                     ??hw_adc_convertstart_11:
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE7E1             B.N      ??hw_adc_convertstart_9
   \                     ??hw_adc_convertstart_6:
   \   000000AA   0x2C04             CMP      R4,#+4
   \   000000AC   0xDA09             BGE.N    ??hw_adc_convertstart_12
   \   000000AE   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   000000B2   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000B6   0x....             LDR.N    R1,??DataTable3_7
   \   000000B8   0x7208             STRB     R0,[R1, #+8]
   \   000000BA   0x....             LDR.N    R1,??DataTable3_7
   \   000000BC   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   000000BE   0x.... 0x....      BL       hw_adc_config_alt
   \                     ??hw_adc_convertstart_12:
   \   000000C2   0x1F20             SUBS     R0,R4,#+4
   \   000000C4   0x2814             CMP      R0,#+20
   \   000000C6   0xD20A             BCS.N    ??hw_adc_convertstart_13
   \   000000C8   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   000000CC   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000D0   0x....             LDR.N    R1,??DataTable3_7
   \   000000D2   0x7208             STRB     R0,[R1, #+8]
   \   000000D4   0x....             LDR.N    R1,??DataTable3_7
   \   000000D6   0x....             LDR.N    R0,??DataTable3_5  ;; 0x400bb000
   \   000000D8   0x.... 0x....      BL       hw_adc_config_alt
   \   000000DC   0xE7C6             B.N      ??hw_adc_convertstart_8
   \                     ??hw_adc_convertstart_13:
   \   000000DE   0x2C1A             CMP      R4,#+26
   \   000000E0   0xD10A             BNE.N    ??hw_adc_convertstart_14
   \   000000E2   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   000000E6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000EA   0x....             LDR.N    R1,??DataTable3_7
   \   000000EC   0x7208             STRB     R0,[R1, #+8]
   \   000000EE   0x....             LDR.N    R1,??DataTable3_7
   \   000000F0   0x....             LDR.N    R0,??DataTable3_5  ;; 0x400bb000
   \   000000F2   0x.... 0x....      BL       hw_adc_config_alt
   \   000000F6   0xE7B9             B.N      ??hw_adc_convertstart_8
   \                     ??hw_adc_convertstart_14:
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xE7B8             B.N      ??hw_adc_convertstart_9
    242          }
    243          //============================================================================
    244          //函数名称：hw_adc_config_alt
    245          //函数返回：无符号结果值(范围:0-4095) 
    246          //参数说明：adcmap：adc基址寄存器地址
    247          //          ADC_CfgPtr: 存放 寄存器值的结构体    
    248          //功能概要：将adc寄存器结构体配置进adc寄存器 
    249          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    250          void ADC_Config_Alt(ADC_MemMapPtr adcmap, tADC_ConfigPtr ADC_CfgPtr)
    251          {
    252              ADC_CFG1_REG(adcmap) = ADC_CfgPtr->CONFIG1;
   \                     ADC_Config_Alt:
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x6082             STR      R2,[R0, #+8]
    253              ADC_CFG2_REG(adcmap) = ADC_CfgPtr->CONFIG2;
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x60C2             STR      R2,[R0, #+12]
    254              ADC_CV1_REG(adcmap)  = ADC_CfgPtr->COMPARE1; 
   \   00000008   0x884A             LDRH     R2,[R1, #+2]
   \   0000000A   0x6182             STR      R2,[R0, #+24]
    255              ADC_CV2_REG(adcmap)  = ADC_CfgPtr->COMPARE2;
   \   0000000C   0x888A             LDRH     R2,[R1, #+4]
   \   0000000E   0x61C2             STR      R2,[R0, #+28]
    256              ADC_SC2_REG(adcmap)  = ADC_CfgPtr->STATUS2;
   \   00000010   0x798A             LDRB     R2,[R1, #+6]
   \   00000012   0x6202             STR      R2,[R0, #+32]
    257              ADC_SC3_REG(adcmap)  = ADC_CfgPtr->STATUS3;
   \   00000014   0x79CA             LDRB     R2,[R1, #+7]
   \   00000016   0x6242             STR      R2,[R0, #+36]
    258              ADC_PGA_REG(adcmap)  = ADC_CfgPtr->PGA;
   \   00000018   0x68CA             LDR      R2,[R1, #+12]
   \   0000001A   0x6502             STR      R2,[R0, #+80]
    259              ADC_SC1_REG(adcmap,A)= ADC_CfgPtr->STATUS1A;       
   \   0000001C   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000001E   0x6002             STR      R2,[R0, #+0]
    260              ADC_SC1_REG(adcmap,B)= ADC_CfgPtr->STATUS1B;
   \   00000020   0x7A49             LDRB     R1,[R1, #+9]
   \   00000022   0x6041             STR      R1,[R0, #+4]
    261          }
   \   00000024   0x4770             BX       LR               ;; return
    262          
    263          

   \                                 In section .text, align 2, keep-with-next
    264          void hw_adc_config_alt(ADC_MemMapPtr adcmap, tADC_ConfigPtr ADC_CfgPtr)
    265          {
    266              ADC_CFG1_REG(adcmap) = ADC_CfgPtr->CONFIG1;
   \                     hw_adc_config_alt:
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x6082             STR      R2,[R0, #+8]
    267              ADC_CFG2_REG(adcmap) = ADC_CfgPtr->CONFIG2;
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x60C2             STR      R2,[R0, #+12]
    268              ADC_CV1_REG(adcmap)  = ADC_CfgPtr->COMPARE1; 
   \   00000008   0x884A             LDRH     R2,[R1, #+2]
   \   0000000A   0x6182             STR      R2,[R0, #+24]
    269              ADC_CV2_REG(adcmap)  = ADC_CfgPtr->COMPARE2;
   \   0000000C   0x888A             LDRH     R2,[R1, #+4]
   \   0000000E   0x61C2             STR      R2,[R0, #+28]
    270              ADC_SC2_REG(adcmap)  = ADC_CfgPtr->STATUS2;
   \   00000010   0x798A             LDRB     R2,[R1, #+6]
   \   00000012   0x6202             STR      R2,[R0, #+32]
    271              ADC_SC3_REG(adcmap)  = ADC_CfgPtr->STATUS3;
   \   00000014   0x79CA             LDRB     R2,[R1, #+7]
   \   00000016   0x6242             STR      R2,[R0, #+36]
    272              ADC_PGA_REG(adcmap)  = ADC_CfgPtr->PGA;
   \   00000018   0x68CA             LDR      R2,[R1, #+12]
   \   0000001A   0x6502             STR      R2,[R0, #+80]
    273              ADC_SC1_REG(adcmap,A)= ADC_CfgPtr->STATUS1A;       
   \   0000001C   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000001E   0x6002             STR      R2,[R0, #+0]
    274              ADC_SC1_REG(adcmap,B)= ADC_CfgPtr->STATUS1B;
   \   00000020   0x7A49             LDRB     R1,[R1, #+9]
   \   00000022   0x6041             STR      R1,[R0, #+4]
    275          }
   \   00000024   0x4770             BX       LR               ;; return
    276          
    277          //============================================================================
    278          //函数名称：hw_adc_convertstop
    279          //函数返回：0 成功 ，1 失败
    280          //参数说明：MoudelNumber：模块号
    281          //               Channel：通道号
    282          //功能概要：停止ADC转换  
    283          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    284          uint8 hw_adc_convertstop(int MoudelNumber,int Channel)
    285          {
   \                     hw_adc_convertstop:
   \   00000000   0xB580             PUSH     {R7,LR}
    286              if(MoudelNumber == 0)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD117             BNE.N    ??hw_adc_convertstop_0
    287              {
    288                  if(Channel>3&&Channel<24)                             //4~23 使用 ADC0
   \   00000006   0x1F08             SUBS     R0,R1,#+4
   \   00000008   0x2814             CMP      R0,#+20
   \   0000000A   0xD208             BCS.N    ??hw_adc_convertstop_1
    289                  {
    290                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(0x1F);
   \   0000000C   0x....             LDR.N    R0,??DataTable3_7
   \   0000000E   0x215F             MOVS     R1,#+95
   \   00000010   0x7201             STRB     R1,[R0, #+8]
    291                      ADC_Config_Alt(ADC0_BASE_PTR, &Master_Adc_Config);  // 配置ADC0
   \   00000012   0x....             LDR.N    R1,??DataTable3_7
   \   00000014   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   00000016   0x.... 0x....      BL       ADC_Config_Alt
    292                  }
    293                  else if(Channel == 26)
    294                  {
    295                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(0x1F);
    296                      ADC_Config_Alt(ADC0_BASE_PTR, &Master_Adc_Config);  // 配置ADC0
    297                  }
    298                  else
    299                  {
    300                      return 0;
    301                  }
    302              }
    303              else if(MoudelNumber == 1)
    304              {
    305                  if(Channel>3&&Channel<24)                             //4~23 使用 ADC1
    306                  {
    307                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(0x1F);
    308                      ADC_Config_Alt(ADC1_BASE_PTR, &Master_Adc_Config);  //  配置ADC1
    309                  }
    310                  else if(Channel == 26)
    311                  {
    312                      Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(0x1F);
    313                      ADC_Config_Alt(ADC1_BASE_PTR, &Master_Adc_Config);  //  配置ADC1
    314                  }
    315                  else
    316                  {
    317                      return 0;
    318                  }
    319              }
    320              else
    321              {
    322                  return 0;
    323              }
    324              return 1;
   \                     ??hw_adc_convertstop_2:
   \   0000001A   0x2001             MOVS     R0,#+1
   \                     ??hw_adc_convertstop_3:
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   \                     ??hw_adc_convertstop_1:
   \   0000001E   0x291A             CMP      R1,#+26
   \   00000020   0xD107             BNE.N    ??hw_adc_convertstop_4
   \   00000022   0x....             LDR.N    R0,??DataTable3_7
   \   00000024   0x215F             MOVS     R1,#+95
   \   00000026   0x7201             STRB     R1,[R0, #+8]
   \   00000028   0x....             LDR.N    R1,??DataTable3_7
   \   0000002A   0x....             LDR.N    R0,??DataTable3_3  ;; 0x4003b000
   \   0000002C   0x.... 0x....      BL       ADC_Config_Alt
   \   00000030   0xE7F3             B.N      ??hw_adc_convertstop_2
   \                     ??hw_adc_convertstop_4:
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE7F2             B.N      ??hw_adc_convertstop_3
   \                     ??hw_adc_convertstop_0:
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD116             BNE.N    ??hw_adc_convertstop_5
   \   0000003A   0x1F08             SUBS     R0,R1,#+4
   \   0000003C   0x2814             CMP      R0,#+20
   \   0000003E   0xD207             BCS.N    ??hw_adc_convertstop_6
   \   00000040   0x....             LDR.N    R0,??DataTable3_7
   \   00000042   0x215F             MOVS     R1,#+95
   \   00000044   0x7201             STRB     R1,[R0, #+8]
   \   00000046   0x....             LDR.N    R1,??DataTable3_7
   \   00000048   0x....             LDR.N    R0,??DataTable3_5  ;; 0x400bb000
   \   0000004A   0x.... 0x....      BL       ADC_Config_Alt
   \   0000004E   0xE7E4             B.N      ??hw_adc_convertstop_2
   \                     ??hw_adc_convertstop_6:
   \   00000050   0x291A             CMP      R1,#+26
   \   00000052   0xD107             BNE.N    ??hw_adc_convertstop_7
   \   00000054   0x....             LDR.N    R0,??DataTable3_7
   \   00000056   0x215F             MOVS     R1,#+95
   \   00000058   0x7201             STRB     R1,[R0, #+8]
   \   0000005A   0x....             LDR.N    R1,??DataTable3_7
   \   0000005C   0x....             LDR.N    R0,??DataTable3_5  ;; 0x400bb000
   \   0000005E   0x.... 0x....      BL       ADC_Config_Alt
   \   00000062   0xE7DA             B.N      ??hw_adc_convertstop_2
   \                     ??hw_adc_convertstop_7:
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE7D9             B.N      ??hw_adc_convertstop_3
   \                     ??hw_adc_convertstop_5:
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE7D7             B.N      ??hw_adc_convertstop_3
    325          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40048018         DC32     0x40048018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x4003B010         DC32     0x4003b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x400BB000         DC32     0x400bb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x400BB010         DC32     0x400bb010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     Master_Adc_Config

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC_Config_Alt
       32  hw_ad_ave
             32 -> hw_ad_mid
       24  hw_ad_mid
             24 -> hw_ad_once
       16  hw_ad_once
             16 -> hw_adc_convertstart
        0  hw_adc_config_alt
        8  hw_adc_convertstart
              8 -> hw_adc_config_alt
        8  hw_adc_convertstop
              8 -> ADC_Config_Alt
        0  hw_adc_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
      38  ADC_Config_Alt
      16  Master_Adc_Config
      66  hw_ad_ave
     102  hw_ad_mid
      74  hw_ad_once
      38  hw_adc_config_alt
     252  hw_adc_convertstart
     108  hw_adc_convertstop
      78  hw_adc_init

 
  16 bytes in section .bss
 788 bytes in section .text
 
 788 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
